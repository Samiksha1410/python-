# -*- coding: utf-8 -*-
"""passwordcracker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1otq3g8Kuoq-otVnoDco8VOzAqxjjsKlt
"""

import hashlib
import itertools
import string
import threading
from queue import Queue

# ==== USER INPUT ====
target_hash = input("Enter the hashed password: ").strip()
hash_type = input("Enter hash type (md5, sha1, sha256): ").strip().lower()
attack_type = input("Choose attack method (dictionary / brute): ").strip().lower()

# ==== HASH FUNCTION MAPPER ====
def get_hash(password):
    if hash_type == "md5":
        return hashlib.md5(password.encode()).hexdigest()
    elif hash_type == "sha1":
        return hashlib.sha1(password.encode()).hexdigest()
    elif hash_type == "sha256":
        return hashlib.sha256(password.encode()).hexdigest()
    else:
        print("Unsupported hash type!")
        exit(1)

# ==== DICTIONARY ATTACK ====
def dictionary_attack(wordlist_path):
    try:
        with open(wordlist_path, "r", encoding="utf-8") as file:
            for line in file:
                word = line.strip()
                if get_hash(word) == target_hash:
                    print(f"\n✅ Password cracked: {word}")
                    return True
        print("\n❌ Password not found in wordlist.")
    except FileNotFoundError:
        print("❌ Wordlist file not found.")
    return False

# ==== BRUTE FORCE ATTACK ====
def brute_worker(charset, length_range, found_flag):
    for length in length_range:
        for combo in itertools.product(charset, repeat=length):
            if found_flag[0]:
                return  # Stop if found
            word = ''.join(combo)
            if get_hash(word) == target_hash:
                print(f"\n✅ Password cracked: {word}")
                found_flag[0] = True
                return

def brute_force_attack(min_len, max_len, threads=4):
    charset = string.ascii_lowercase + string.digits  # You can expand this
    length_range = list(range(min_len, max_len + 1))
    found_flag = [False]

    # Divide work for threads
    chunk_size = len(length_range) // threads
    thread_list = []

    for i in range(threads):
        sub_range = length_range[i * chunk_size:(i + 1) * chunk_size] or length_range
        t = threading.Thread(target=brute_worker, args=(charset, sub_range, found_flag))
        t.start()
        thread_list.append(t)

    for t in thread_list:
        t.join()

    if not found_flag[0]:
        print("\n❌ Password not cracked using brute force.")

# ==== MAIN EXECUTION ====
if attack_type == "dictionary":
    wordlist = input("Enter path to wordlist file: ").strip()
    dictionary_attack(wordlist)

elif attack_type == "brute":
    min_len = int(input("Enter minimum password length: "))
    max_len = int(input("Enter maximum password length: "))
    brute_force_attack(min_len, max_len)

else:
    print("❌ Invalid attack type. Use 'dictionary' or 'brute'.")

import hashlib
print(hashlib.md5("secret".encode()).hexdigest())
# Output: 5ebe2294ecd0e0f08eab7690d2a6ee69